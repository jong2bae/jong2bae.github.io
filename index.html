<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/smooth-scrollbar/1.1.9/smooth_scrollbar.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Nanum+Brush+Script&amp;family=Noto+Serif+KR:wght@200..900&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&amp;family=Gasoek+One&amp;family=Montserrat:ital,wght@0,100..900;1,100..900&amp;display=swap" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/swiper@10/swiper-bundle.min.css" rel="stylesheet"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vanilla-tilt"></script>
<script src="https://cdn.jsdelivr.net/npm/swiper@10/swiper-bundle.min.js"></script>
<title>Portfolio Template</title>
</head>
<script>
$(document).ready(function () {
    $('#menu ul li').on('click', function () {
        var index = $(this).index();
        $('#menu ul li').removeClass('is--on');
        $('#menu ul').each(function () {
            $(this).find('li').eq(index).addClass('is--on');
        });

        
        $('.sec').removeClass('is--on');
        $('.sec').eq(index).addClass('is--on');
    });

    $('.site-map-btn').on('click', function () {
        $('.site-map').addClass('is--on');
    });

    var CloseItem = $('.site-map .close, .site-map .conts-right #menu')
    CloseItem.on('click', function () {
        $('.site-map').removeClass('is--on');
    });
});


</script>
<style>
*{padding:0; margin:0; border:0; box-sizing: border-box;}
body{ width:100%; height:100vh; font-family: 'Noto Sans KR', sans-serif; color:#fff; background:#0a1f44; overflow: hidden; }
.en{font-family: 'Montserrat', sans-serif !important;}
.en2{font-family: "Noto Serif KR", serif !important}
ul,li{list-style: none;}
a{text-decoration: none; color:#fff;}
canvas{position: fixed; left:0; top:0; width:100%; height:100%; opacity: .95;}
.b_type1{ display: inline-flex; justify-content: center; align-items: center; gap:15px; height:55px; font-size:16px; font-weight: 500; color:#0a1f44; background:#fff; }
.icon{ display: inline-flex; width:24px; height:24px; }
.arrow-right01{ background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1em' height='1em' viewBox='0 0 24 24'%3E%3C!-- Icon from All by undefined - undefined --%3E%3Cpath fill='%23252525' d='m14 18l-1.4-1.45L16.15 13H4v-2h12.15L12.6 7.45L14 6l6 6z'/%3E%3C/svg%3E") no-repeat center / 100%; }

header{ display: flex; justify-content: space-between; position: fixed; left:0; top:0; width:100%; padding:42px; z-index: 100000; }
header .logo{ font-size:32px; font-weight: 800; }
header .site-map-btn{ display: flex; flex-direction: column; justify-content: center; align-items: flex-start; gap:7px; position: relative; width:40px; height:40px; cursor: pointer; }
header .site-map-btn::before, header .site-map-btn::after { content:''; width:100%; height:3px; border-radius: 100px; background:#fff; }
header .site-map-btn::after{ width:65%; transition: all .3s ease; }
header .site-map-btn:hover::after{ width:100%; }
.main{ width:100%; height:100%; }
.main-bg{ position: fixed; left:50%; top:50%; transform: translate(-50%,-50%); content:''; width:100%; height:100%; background:url('https://blog.kakaocdn.net/dn/TfIrE/btsNSBY75Fb/SpOyvqENMcXCDjhYMWani1/img.jpg') no-repeat center / cover;  filter: grayscale(1) brightness(.25) hue-rotate(100deg); }
.main-inner{ display: flex; position: relative; width:100%; height:100%; }
.left_menu{ display: flex; flex-direction: column; justify-content: center; gap:25px; position: fixed; left:25%; transform: translateX(-100%); z-index: 10000; height:100%; }
.left_menu h3{ font-weight: 700; opacity: .5; }
.left_menu ul{ display: flex; flex-direction: column; gap:15px; }
.left_menu ul li{ height:100px; cursor: pointer; }
.left_menu ul li div{ position: relative; display: flex; flex-direction: column; justify-content: center; height:100%; white-space: nowrap; }
.left_menu ul li div::before{ position: absolute; content:''; left:-50px; top:0; width:0; height:100%; z-index: -1; transition: all .3s ease; background:#4682B4; }
.left_menu ul li.is--on div::before{ width:100px; }
.left_menu ul li:hover div::before{ width:25px; }
.left_menu ul li.is--on div::before,
.left_menu ul li.is--on:hover div::before { width:75px; }
.left_menu ul li .desc1{ font-size:32px; font-weight: 700; }
.left_menu ul li:hover .desc1{ opacity: .75; }
.left_menu ul li span{ opacity: .5; transition: all .3s ease; }
.left_menu ul li.is--on:hover .desc1{ opacity: .75; }
.left_menu ul li.is--on span{ opacity: 1; }
.left_menu ul li.is--on .desc2{ opacity: .5; }

.sec-wrap{position: relative; flex:auto;}

.sec{ position: absolute; left:25%; display: flex; align-items: center; justify-content: center; width:75%; height:100%; opacity: 0; visibility: hidden; transition: all .5s ease; }
.sec.is--on{ opacity: 1; visibility: initial; }
.sec .sec-inner{ width:100%; height:100%; padding-left:50px;}

.prot .swiper{ width:100%; height:100%; overflow: initial; }
.prot .swiper-slide .content{ display: flex; align-items: center; justify-content: center; position: relative; width:100%; height:100%; filter: brightness(25%); transition: all .3s ease; }
.prot .swiper-slide-active .content{ filter: brightness(95%); }
.prot .swiper-slide .conts-inner{ position: relative; max-width:768px; width:100%; }
.prot .swiper-slide .img_box{ display: flex; align-items: center; justify-content: center; width:100%; box-shadow: 0 30px 30px -30px rgba(0, 0, 0, 1); transition: all .75s ease; transform: scale(.85); }
.prot .swiper-slide-active .img_box{ transform: scale(1.2); }
.prot .swiper-slide .img_box img{ width:100%; aspect-ratio: 16 / 9; object-fit: cover; overflow: hidden; filter: brightness(.65);}
.prot .swiper-slide .txt_box{ display: flex; flex-direction: column; align-items: flex-start; gap:20px; position: absolute; left:0; top:50%; transform: translate(-20%, -50%); }
.prot .swiper-slide .txt_box h2{ width:0; font-size:55px; white-space: nowrap; text-shadow: 0 5px 15px rgba(0, 0, 0, .25); overflow: hidden; transition: all 1.25s ease; }
.prot .swiper-slide-active .txt_box h2{ width:calc(100% + 25px); }
.prot .swiper-slide .txt_box a{ width:0; flex-shrink: 0; font-weight: 600; white-space: nowrap; overflow: hidden; opacity: 0; transition: all 1s ease; }
.prot .swiper-slide .txt_box a i{ transform: translateX(0); transition: all .3s ease; }
.prot .swiper-slide .txt_box a:hover i{ transform: translateX(10px); }
.prot .swiper-slide-active .txt_box a{ width:190px; flex-shrink: 0; white-space: nowrap; overflow: hidden; opacity: 1; }
.prot .swiper-slide-active .txt_box a span{ transition: all .3s ease; }
.prot .swiper-scrollbar{ position: fixed; right:60px; top:50%; transform: translateY(-50%); height:calc(75vh); background:rgba(70, 130, 180, .3); }
.prot .swiper-scrollbar-drag{ display: flex; width:65px !important; height:65px !important; left:calc(-61px / 2); background:transparent; cursor: pointer; }
.prot .swiper-scrollbar-drag::before{ position: absolute; left:50%; top:50%; transform: translate(-50%,-50%); content:''; width:100%; height:100%; border:3px solid #4682B4; border-radius: 50%; border-radius: 50%; background:transparent; backdrop-filter: blur(10px); box-shadow: 0 10px 15px rgba(0, 0, 0, .25); transition: all .3s ease; }
.prot .swiper-scrollbar-drag:hover::before{ transform: translate(-50%,-50%) scale(1.25); }
.prot .swiper-scrollbar-drag::after{ position: absolute; left:50%; top:50%; transform: translate(-50%,-50%) rotate(90deg); content:''; width:24px; height:24px; background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1em' height='1em' viewBox='0 0 24 24'%3E%3C!-- Icon from All by undefined - undefined --%3E%3Cpath fill='%23ffffff' d='m9 6l-6 6l6 6zm6 12l6-6l-6-6z'/%3E%3C/svg%3E") no-repeat center / 100%; }

.site-map,.site-map-inner{ position: fixed; left:0; top:0; width:100%; height:100%; z-index: 10000000; overflow: hidden; }
.site-map{ width:0; visibility: hidden; transition: all .75s; }
.site-map.is--on{ width:100%; visibility: inherit; }
.site-map .close{ position: absolute; right:42px; top:42px; width:40px; height:40px; z-index: 10000000; cursor: pointer; opacity: 0; transition: all .5s ease; }
.site-map .close::before{ position: absolute; left:50%; top:50%; transform: translate(-50%,-50%) rotate(45deg); content:''; width:3px; height:100%; border-radius: 100px; background:#fff; }
.site-map .close::after{ position: absolute; left:50%; top:50%; transform: translate(-50%,-50%) rotate(-45deg); content:''; width:3px; height:100%; border-radius: 100px; background:#fff; }
.site-map .close:hover{ transform: scale(1.25); }
.site-map.is--on .close{opacity: 1;}
.site-map .conts-wrap{ display: flex; width:100%; height:100%; }
.site-map .conts-left{ display: flex; flex-wrap: wrap; width:50%; height:100%; }
.site-map .conts-left .cont{ flex:auto; overflow: hidden; }
.site-map .conts-left .cont01{ width:40%; height:60%;}
.site-map .conts-left .cont02{ width:60%; height:60%;}
.site-map .conts-left .cont03{ width:40%; height:40%;}
.site-map .conts-left .cont04{ width:60%; height:40%;}
.site-map .cont-inner{ position: relative; transition: all .75s ease; width:100%; height:100%; overflow: hidden; }
.site-map .conts-left .cont01 .cont-inner{transform: translate(0, 105%); background:#000;}
.site-map .conts-left .cont02 .cont-inner{transform: translate(-105%, 0); background:#0a1f44;}
.site-map .conts-left .cont03 .cont-inner{transform: translate(105%, 0); background:#0a1f44;}
.site-map .conts-left .cont04 .cont-inner{transform: translate(0, -105%); background:#4682B4;}
.site-map.is--on .conts-left .cont-inner{transform: translate(0,0);}
.site-map .conts-right{ width:50%; height:100%; overflow: hidden;}
.site-map .conts-right .cont-inner{ display: flex; align-items: center; justify-content: center; position: relative; transform: translate(0, 105%); width:100%; height:100%; background:#0a1f44; }
.site-map .conts-left .cont01 .cont-inner{ display: flex; align-items: center; justify-content: center; }
.site-map .conts-left .cont01 p{ width:50%; font-size:14px; text-align: center; word-break: keep-all; color:#999; }
.site-map .conts-left .cont02 .cont-inner{ display: flex; background:url(https://jong2bae.github.io/jong2bae_profile.jpg) no-repeat top / cover; filter: brightness(.23) grayscale(1); }
.site-map .conts-left .cont03 .cont-inner{ display: flex; align-items: center; justify-content: center; }
.site-map .conts-left .cont03 .cont-inner ul{display: flex; flex-direction: column; gap:15px;}
.site-map .conts-left .cont03 .cont-inner ul li{ display: flex; align-items: center; justify-content: center; }
.site-map .conts-left .cont03 .cont-inner ul li a{ position: relative; display: flex; align-items: center; justify-content: center; font-size: 18px; color:#505154; transition: all .3s ease; }
.site-map .conts-left .cont03 .cont-inner ul li:hover a{ color:#fff; }
.site-map .conts-left .cont03 .cont-inner ul li a::after{ position: absolute; content:''; left:50%; bottom:-5px; transform: translateX(-50%); content:''; width:0; height:2px; background:#4682B4; transition: all .3s ease; }
.site-map .conts-left .cont03 .cont-inner ul li:hover a::after{width:100%;}
.site-map .conts-left .cont04 .cont-inner{ position: relative; display: flex; align-items: center; justify-content: center; text-align: center; }
.site-map .conts-left .cont04 .cont-inner .bg{ position: absolute; left:50%; top:50%; transform: translate(-50%,-50%) scale(1.15); width:100%; height:100%; background:url(https://i.pinimg.com/736x/1d/14/0b/1d140bafd0da4f085bd6f1a12db98660.jpg) no-repeat center / cover; opacity: .25; z-index: -1; }
.site-map.is--on .conts-right .cont-inner{ transform: translate(0,0);}
.site-map .conts-right .cont-inner .tag{ display: flex; align-items: flex-end; position: absolute; width:0; height:0; }
.site-map .conts-right .cont-inner .tag01{left:42px; top:42px; transform: rotate(90deg);}
.site-map .conts-right .cont-inner .tag02{right:42px; bottom:42px; transform: rotate(-90deg);}
.site-map .conts-right .cont-inner .tag02 span{transform: rotate(180deg);}
.site-map .conts-right .cont-inner .tag p{ display: flex; align-items: center; gap:20px; white-space: nowrap; line-height: 1; color:#4682B4; }
.site-map .conts-right .cont-inner .tag i{ content:''; width:50px; height:.5px; background:#4682B4; }
.site-map .conts-right .cont-inner #menu ul{display: flex; flex-direction: column; gap:100px; transition: all .3s ease;}
.site-map .conts-right .cont-inner #menu ul li{position: relative; cursor: pointer; transition: all .3s ease;}
.site-map .conts-right .cont-inner #menu ul li .txt-wrap{display: flex; flex-direction: column; align-items: center;}
.site-map .conts-right .cont-inner #menu ul li .txt-wrap span{ position: relative; font-size:75px; font-weight: 800; line-height: 1; transition: all .3s ease; }
.site-map .conts-right .cont-inner #menu ul:hover{gap:90px;}
.site-map .conts-right .cont-inner #menu ul:hover li:hover{transform: scale(1.15);}
.site-map .conts-right .cont-inner #menu ul:hover li .txt-wrap span{ color:#505154; }
.site-map .conts-right .cont-inner #menu ul:hover li:hover .txt-wrap span{ color:#fff; }
.site-map .conts-right .cont-inner #menu ul li .txt-wrap span::before{ position: absolute; left:0; top:0; transform: translate(-100%, -100%); font-family: 'Montserrat'; font-size:18px; opacity: .5; }
.site-map .conts-right .cont-inner #menu ul li:nth-child(1) .txt-wrap span::before{content:'01';}
.site-map .conts-right .cont-inner #menu ul li:nth-child(2) .txt-wrap span::before{content:'02';}
.site-map .conts-right .cont-inner #menu ul li:nth-child(3) .txt-wrap span::before{content:'03';}
.site-map .conts-right .cont-inner #menu ul li:nth-child(4) .txt-wrap span::before{content:'04';}
.site-map .conts-right .cont-inner #menu ul li .txt-wrap span::after{ position: absolute; left:-20px; top:50%; transform: translate(0,-50%); content:''; width:0; height:12px; background:#4682B4; transition: all .3s ease; }
.site-map .conts-right .cont-inner #menu ul li:hover .txt-wrap span::after{ width:calc(100% + 40px); }
.sec02 section{padding:0 25vh;}
.sec02 .conts-wrap{ position: relative; width:calc(100% - 250px); margin-left:100px; }
.sec02 .cont{ position: relative; width:calc(100% - 100px); margin-left:100px;}
.sec02 .wrap01 .cont01{ display: flex; justify-content: center; height:100vh; }
.sec02 .wrap01 .txt-group{ display: flex; flex-direction: column; justify-content: center; }
.sec02 .wrap01 .txt-group p{ position: relative; display: flex; align-items: center; font-size:145px; font-weight: 900; text-transform: uppercase; }
.sec02 .wrap01 .txt-group p span{ position: absolute; color:transparent; line-height: 1; -webkit-text-stroke-width: 1px; -webkit-text-stroke-color: white; }
.sec02 .wrap01 .txt-group p:nth-child(1){ color:transparent; -webkit-text-stroke-width: 1px; -webkit-text-stroke-color: rgba(255, 255, 255, .75);; }
.sec02 .wrap01 .txt-group p span:nth-child(1){position: relative; color:#fff;}
.sec02 .wrap01 .txt-group p span:nth-child(2){opacity: .5;}
.sec02 .wrap01 .txt-group p span:nth-child(3){opacity: .25;}
.sec02 .wrap01 .txt-group p span:nth-child(4){opacity: .15;}
.sec02 .wrap01 .txt-group p span:nth-child(5){opacity: .05;}
.sec02 .wrap01 .txt-group p span:nth-child(6){opacity: .01;}
.sec02 .wrap01 .scroll-down{ position: absolute; left:50%; bottom:60px; transform: translateX(-50%); opacity: .75;}
.sec02 .wrap01 .scroll-down div{display: flex; flex-direction: column; align-items: center; gap:10px;}
.sec02 .wrap01 .scroll-down i{ position: relative; width:22px; height:32px; border:1px solid #fff; border-radius: 100px; }
.sec02 .wrap01 .scroll-down i::before{ position: absolute; content:''; left:50%; top:4px; transform: translateX(-50%); width:3px; height:3px; border-radius: 50%; background:#fff; animation: scroll-down 1s linear infinite; }
@keyframes scroll-down { from{top:4px;} to{top:10px;} }
.sec02 .wrap01 .scroll-down span{font-size:12px; text-transform: uppercase;}
.sec02 .wrap02 { display: flex; flex-direction: column; gap:100px; align-items: flex-end; padding:200px 0; }


.sec02 .flex-box{position: relative;}
.sec02 .flex-box > div{display : flex; flex-direction: column; gap:25px;}

.sec02 .flex-left > div{align-items: flex-start; text-align: left;}
.sec02 .flex-right > div{align-items: flex-end; text-align: right;}
.sec02 .flex-center > div{align-items: center; text-align: center;}

.sec02 .flex-box h3,.sec02 .flex-box p{max-width:55%; word-break: keep-all;}
.sec02 .flex-box h3 {font-size:28px;}
.sec02 .flex-box p{font-size:16px; opacity: .75; line-height: 1.6;}

.sec02 .flex-box > div h3 {position: relative; opacity: 0; transition: all .3s ease;}
.sec02 .flex-box > div h3::before{position: absolute; content:''; left:0; bottom:calc(100% + 4px); width:25px; height:2px; background:#4682B4;}
.sec02 .flex-box > div.is--on h3 {opacity: 1;}


.sec02 .flex-box > div p {opacity: 0; transition: all .3s ease;}
.sec02 .flex-box > div.is--on p {opacity: .75;}


.sec02 h2{width:100%; text-align: center; font-size:28px;}

.sec02 .bg-img{position: absolute; z-index: -1; filter: brightness(.25);}
.sec02 .bg-img img{opacity: 0; transition: all .3s ease; }
.sec02 .bg-img.is--on img{opacity: 1;}
.sec02 .wrap02 .bg-img.bg01{left:50%;}
.sec02 .wrap02 .bg-img.bg02{left:0;}
.sec02 .wrap02 .bg-img.bg03{left:5%;}
.sec02 .wrap02 .bg-img.bg04{left:25%;}
.sec02 .wrap02 .bg-img.bg05{left:-5%;}


    .modal{position: fixed; left:0; top:0; width:100%; height:100vh; background:rgba(0, 0, 0, .95); z-index: 99999999999; visibility: hidden; opacity: 0; transition: all .3s ease; overflow-y: auto;}
    .modal::-webkit-scrollbar{width:0;}
    .modal.is--on{opacity: 1; visibility: inherit;}
    .modal .close{position: fixed; right:25px; top:25px; width:50px; height:50px; background:#4682B4; cursor: pointer;}
    .modal .close::before{position: absolute; content:''; left:50%; top:50%; transform: translate(-50%, -50%) rotate(45deg); width:65%; height:1px; background:#fff;}
    .modal .close::after{position: absolute; content:''; left:50%; top:50%; transform: translate(-50%, -50%) rotate(-45deg); width:65%; height:1px; background:#fff;}
    .modal .container{display : flex; justify-content: center;width:100%; padding:150px 0;}
    .modal .content{position: relative; display : flex; align-items: flex-start; gap:75px; max-width:1024px; width:100%; }
    .modal .img_box{display : flex; flex-direction: column; gap:25px; width:50%;}
    .modal .img_box img{width:100%;}
    .modal .info_box{position: sticky; top:150px; display : flex; flex-direction: column; gap:50px;}
    .modal .txt_group{display : flex; flex-direction: column; gap:25px;}
    .modal .info_box h4{font-size:24px;}
    .modal .info_box ul{display : flex; flex-direction: column; gap:10px;}
    .modal .info_box ul li{position: relative; padding-left:12px; font-size:16px; opacity: .75; word-break: keep-all;}
    .modal .info_box ul li::before{position: absolute; content:''; top:11px; left:0; width:3px; height:3px; background: #4682B4;;}
    .modal.prot-0104 .container{flex-direction: column; align-items: center; gap:100px;}
    .modal.prot-0104 .content{flex-direction: column; align-items: center; gap:25px;}
    .modal.prot-0104 .img_box{width:100%;}
    .modal.prot-0104 .img_box img{user-select: none; -webkit-user-drag: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
    .modal.prot-0104 .info_box{width:100%;}
</style>
<body>
<!-- header -->
<header>
<a class="logo en" href="">KIM JONG BAE</a>
<div class="site-map-btn"></div>
</header>
<!-- site-map -->
<div class="site-map is--on">
<div class="site-map-inner">
<div class="close"></div>
<div class="conts-wrap">
<div class="conts-left">
<div class="cont cont01">
<div class="cont-inner">
<p></p>
</div>
</div>
<div class="cont cont02">
<div class="cont-inner"></div>
</div>
<div class="cont cont03">
<div class="cont-inner">
<ul class="contact"><li>kjongbae@naver.com</li></ul>
</div>
</div>
<div class="cont cont04">
<div class="cont-inner">
<div class="bg"></div>
<span class="en2">A project manager who understands the field, <br/>a strategist who solves problems.</span>
</div>
</div>
</div>
<div class="conts-right">
<div class="cont-inner">
<div class="tag tag01"> <p></p> </div>
<div class="tag tag02"> <p></p> </div>
<div id="menu">
<ul>
<li class="is--on">
<div class="txt-wrap">
<span class="desc1 en">Portfolio</span>
</div>
</li>
<li class="">
<div class="txt-wrap">
<span class="desc1 en">Profile</span>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<!-- main -->
<main class="main">
<canvas id="fluid"></canvas>
<div class="main-inner">
<div class="left_menu" id="menu">
<h3 class="en">메뉴</h3>
<ul>
<li class="is--on">
<div class="">
<span class="desc1 en">Portfolio</span>
<span class="desc2">포트폴리오</span>
</div>
</li>
<li class="">
<div class="">
<span class="desc1 en">Profile</span>
<span class="desc2">프로필</span>
</div>
</li>
</ul>
</div>
<div class="sec-wrap">
<section class="sec prot is--on">
<div class="sec-inner">
<div class="swiper prot-swiper">
<div class="swiper-wrapper">
<div class="swiper-slide">
<div class="content tilt-card">
<div class="conts-inner">
<div class="img_box"></div>
<div class="txt_box">
<h2>프로젝트 1제목</h2>
<a class="b_type1 en port-item01" href="javascript:void(0)"><span>PLACEHOLDER</span><i class="icon arrow-right01"></i></a>
</div>
</div>
</div>
</div>
<div class="swiper-slide">
<div class="content tilt-card">
<div class="conts-inner">
<div class="img_box"></div>
<div class="txt_box">
<h2>프로젝트 2제목</h2>
<a class="b_type1 en port-item02" href="javascript:void(0)"><span>PLACEHOLDER</span><i class="icon arrow-right01"></i></a>
</div>
</div>
</div>
</div>
<div class="swiper-slide">
<div class="content tilt-card">
<div class="conts-inner">
<div class="img_box"></div>
<div class="txt_box">
<h2>프로젝트 3제목</h2>
<a class="b_type1 en port-item03" href="javascript:void(0)"><span>PLACEHOLDER</span><i class="icon arrow-right01"></i></a>
</div>
</div>
</div>
</div>
<div class="swiper-slide">
<div class="content tilt-card">
<div class="conts-inner">
<div class="img_box"></div>
<div class="txt_box">
<h2>프로젝트 4제목</h2>
<a class="b_type1 en port-item04" href="javascript:void(0)"><span>PLACEHOLDER</span><i class="icon arrow-right01"></i></a>
</div>
</div>
</div>
</div>
</div>
<div class="swiper-scrollbar"></div>
</div>
</div>
<script>
                        var swiper = new Swiper(".prot-swiper", {
                            direction: "vertical",
                            slidesPerView: 1.75,
                            loopedSlides: 2,
                            speed: 750,
                            spaceBetween: 100,
                            parallax: true,
                            centeredSlides: true,
                            scrollbar: {
                                el: ".swiper-scrollbar",
                                draggable: true,
                            },
                            mousewheel: {
                                invert: false,
                                forceToAxis: true,
                                sensitivity: 1,
                                releaseOnEdges: true,
                            },
                            breakpoints: {
                                1024: {},
                            },
                        });

                    </script>
</section>
<section class="sec sec02">
<div class="sec-inner">
<div data-scroll-container="">
<div class="conts-wrap wrap01" data-scroll-section="">
<div class="cont cont01">
<div class="txt-group">
<p class="en" data-scroll="" data-scroll-position="top"></p>
<p></p>
</div>
</div>
<div class="scroll-down">
<div data-scroll="" data-scroll-position="top">
<i></i>
<span>PLACEHOLDER</span>
</div>
</div>
</div>
<div class="conts-wrap wrap02" data-scroll-section="">
<div class="flex-box flex-left">
<div data-scroll="" data-scroll-class="is--on" data-scroll-position="top" data-scroll-speed="3">
<h3>섹션 제목</h3>
<p></p>
</div>
<div class="bg-img bg01" data-scroll="" data-scroll-class="is--on" data-scroll-position="top"></div>
</div>
<div class="flex-box flex-left">
<div data-scroll="" data-scroll-class="is--on" data-scroll-position="top" data-scroll-speed="2.5">
<h3>섹션 제목</h3>
<p></p>
</div>
<div class="bg-img bg02" data-scroll="" data-scroll-class="is--on" data-scroll-position="top"></div>
</div>
<div class="flex-box flex-left">
<div data-scroll="" data-scroll-class="is--on" data-scroll-position="top" data-scroll-speed="1">
<h3>섹션 제목</h3>
<p></p>
</div>
<div class="bg-img bg05" data-scroll="" data-scroll-class="is--on" data-scroll-position="top"></div>
</div>
<h2>프로젝트 제목</h2>
</div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/locomotive-scroll@4.1.1/dist/locomotive-scroll.min.js"></script>
<script>
                        const body = document.body;
                        const backToTop = document.querySelector(".back-to-top");
                        const opacityClass = "opacity-0";
                        const visibilityClass = "invisible";

                        const scroll = new LocomotiveScroll({
                            el: document.querySelector("[data-scroll-container]"),
                            smooth: true,
                            lerp: 0.075,
                            multiplier: 0.5,
                            tablet: { smooth: true },
                            smartphone: { smooth: true }
                        });

                    </script>
</section>
</div>
</div>
</main>
<div class="modal prot-0101">
<div class="close"></div>
<div class="container">
<div class="content">
<div class="img_box">

</div>
<div class="info_box">
<div class="txt_group">
<h4>항목 제목</h4>
<ul>
<li>설명 텍스트 자리</li>
</ul>
</div>
<div class="txt_group">
<h4>항목 제목</h4>
<ul>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
</ul>
</div>
<div class="txt_group">
<h4>항목 제목</h4>
<ul>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="modal prot-0102">
<div class="close"></div>
<div class="container">
<div class="content">
<div class="img_box">




</div>
<div class="info_box">
<div class="txt_group">
<h4>항목 제목</h4>
<ul>
<li>설명 텍스트 자리</li>
</ul>
</div>
<div class="txt_group">
<h4>항목 제목</h4>
<ul>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
</ul>
</div>
<div class="txt_group">
<h4>항목 제목</h4>
<ul>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="modal prot-0103">
<div class="close"></div>
<div class="container">
<div class="content">
<div class="img_box">



</div>
<div class="info_box">
<div class="txt_group">
<h4>항목 제목</h4>
<ul>
<li>설명 텍스트 자리</li>
</ul>
</div>
<div class="txt_group">
<h4>항목 제목</h4>
<ul>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
<li>설명 텍스트 자리</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="modal prot-0104">
<div class="close"></div>
<div class="container">
<div class="content">
<div class="img_box">

</div>
<div class="info_box">
<div class="txt_group">
<ul>
<li>설명 텍스트 자리</li>
</ul>
</div>
</div>
</div>
<div class="content">
<div class="img_box">

</div>
<div class="info_box">
<div class="txt_group">
<ul>
<li>설명 텍스트 자리</li>
</ul>
</div>
</div>
</div>
<div class="content">
<div class="img_box">

</div>
<div class="info_box">
<div class="txt_group">
<ul>
<li>설명 텍스트 자리</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<script>
        $(document).ready(function () {
            $(".tilt-card").each(function () {
                VanillaTilt.init(this, {
                    max: 5,
                    speed: 2000,
                    glare: false,
                    "max-glare": 0.5
                });
            });
        });
    </script>
<script>
        $(document).ready(function(){
            $(".port-item01").click(function(){
                $('.prot-0101').addClass('is--on')
            });

            $(".port-item02").click(function(){
                $('.prot-0102').addClass('is--on')
            });

            $(".port-item03").click(function(){
                $('.prot-0103').addClass('is--on')
            });

            $(".port-item04").click(function(){
                $('.prot-0104').addClass('is--on')
            });


            $('.modal .close').click(function(){
                $('.modal').removeClass('is--on')
            })
        });

    </script>
<script>
        window.addEventListener('load', () => { initFluid(); });
        const initFluid = () => {
            // anim setup || in an active project you can set this to the html body. however ive found a bound box to the viewport looks + performs better
            const canvas = document.getElementById('fluid');
            resizeCanvas();

            let config = {

                SIM_RESOLUTION: 64, // 시뮬레이션 해상도 (숫자가 클수록 정밀하지만 성능 부담 증가)
                DYE_RESOLUTION: 720, // 염료(색상) 해상도 (높을수록 색상 표현이 더 정교해짐)
                CAPTURE_RESOLUTION: 256, // 캡처(렌더링) 해상도 설정
                DENSITY_DISSIPATION: 3, // 밀도(염료)의 소멸 속도 (높을수록 더 빨리 사라짐)
                VELOCITY_DISSIPATION: 1, // 유체 속도의 감쇠율 (높을수록 빠르게 속도가 줄어듦)
                PRESSURE: 0.1, // 유체 압력 값 (낮을수록 부드러운 흐름, 높을수록 거친 흐름)
                PRESSURE_ITERATIONS: 5, // 압력 연산 반복 횟수 (높을수록 정확하지만 성능 부담 증가)
                CURL: 0, // 회오리 강도 (유체가 얼마나 소용돌이치는지 결정)
                SPLAT_RADIUS: 0.2, // 스플랫(입력된 힘)의 반경 크기 (값이 클수록 넓게 퍼짐)
                SPLAT_FORCE: 1500, // 스플랫(입력된 힘)의 강도 (값이 클수록 강하게 퍼짐)
                SHADING: true, // 음영 효과 활성화 여부 (true면 입체감 있는 표현 가능)
                COLOR_UPDATE_SPEED: 0, // 색상이 업데이트되는 속도 (값이 클수록 색상 변화가 빠름)
                PAUSED: true,
                TRANSPARENT: true, // 배경을 투명하게 설정 (true면 배경이 없음)

            }

            function pointerPrototype() {
                this.id = -1;
                this.texcoordX = 0;
                this.texcoordY = 0;
                this.prevTexcoordX = 0;
                this.prevTexcoordY = 0;
                this.deltaX = 0;
                this.deltaY = 0;
                this.down = false;
                this.moved = false;
                this.color = [255, 0, 300];
            }

            let pointers = [];
            pointers.push(new pointerPrototype());

            const { gl, ext } = getWebGLContext(canvas);

            if (!ext.supportLinearFiltering) {
                config.DYE_RESOLUTION = 512;
                config.SHADING = false;
            }

            function getWebGLContext(canvas) {
                const params = { alpha: true, depth: false, stencil: false, antialias: false, preserveDrawingBuffer: false };

                let gl = canvas.getContext('webgl2', params);
                const isWebGL2 = !!gl;
                if (!isWebGL2)
                    gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);

                let halfFloat;
                let supportLinearFiltering;
                if (isWebGL2) {
                    gl.getExtension('EXT_color_buffer_float');
                    supportLinearFiltering = gl.getExtension('OES_texture_float_linear');
                } else {
                    halfFloat = gl.getExtension('OES_texture_half_float');
                    supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');
                }

                gl.clearColor(0.0, 0.0, 0.0, 1.0);

                const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;
                let formatRGBA;
                let formatRG;
                let formatR;

                if (isWebGL2) {
                    formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
                    formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
                    formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
                }
                else {
                    formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                    formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                    formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                }

                return {
                    gl,
                    ext: {
                        formatRGBA,
                        formatRG,
                        formatR,
                        halfFloatTexType,
                        supportLinearFiltering
                    }
                };
            }

            function getSupportedFormat(gl, internalFormat, format, type) {
                if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
                    switch (internalFormat) {
                        case gl.R16F:
                            return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
                        case gl.RG16F:
                            return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
                        default:
                            return null;
                    }
                }

                return {
                    internalFormat,
                    format
                }
            }

            function supportRenderTextureFormat(gl, internalFormat, format, type) {
                let texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);

                let fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

                let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                return status == gl.FRAMEBUFFER_COMPLETE;
            }

            class Material {
                constructor(vertexShader, fragmentShaderSource) {
                    this.vertexShader = vertexShader;
                    this.fragmentShaderSource = fragmentShaderSource;
                    this.programs = [];
                    this.activeProgram = null;
                    this.uniforms = [];
                }

                setKeywords(keywords) {
                    let hash = 0;
                    for (let i = 0; i < keywords.length; i++)
                        hash += hashCode(keywords[i]);

                    let program = this.programs[hash];
                    if (program == null) {
                        let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);
                        program = createProgram(this.vertexShader, fragmentShader);
                        this.programs[hash] = program;
                    }

                    if (program == this.activeProgram) return;

                    this.uniforms = getUniforms(program);
                    this.activeProgram = program;
                }

                bind() {
                    gl.useProgram(this.activeProgram);
                }
            }

            class Program {
                constructor(vertexShader, fragmentShader) {
                    this.uniforms = {};
                    this.program = createProgram(vertexShader, fragmentShader);
                    this.uniforms = getUniforms(this.program);
                }

                bind() {
                    gl.useProgram(this.program);
                }
            }

            function createProgram(vertexShader, fragmentShader) {
                let program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS))
                    console.trace(gl.getProgramInfoLog(program));

                return program;
            }

            function getUniforms(program) {
                let uniforms = [];
                let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    let uniformName = gl.getActiveUniform(program, i).name;
                    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
                }
                return uniforms;
            }

            function compileShader(type, source, keywords) {
                source = addKeywords(source, keywords);

                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
                    console.trace(gl.getShaderInfoLog(shader));

                return shader;

            };

            function addKeywords(source, keywords) {
                if (keywords == null) return source;
                let keywordsString = '';
                keywords.forEach(keyword => {
                    keywordsString += '#define ' + keyword + '\n';
                });

                return keywordsString + source;
            }

            const baseVertexShader = compileShader(gl.VERTEX_SHADER, `
            precision highp float;
        
            attribute vec2 aPosition;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform vec2 texelSize;
        
            void main () {
                vUv = aPosition * 0.5 + 0.5;
                vL = vUv - vec2(texelSize.x, 0.0);
                vR = vUv + vec2(texelSize.x, 0.0);
                vT = vUv + vec2(0.0, texelSize.y);
                vB = vUv - vec2(0.0, texelSize.y);
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `);

            const blurVertexShader = compileShader(gl.VERTEX_SHADER, `
            precision highp float;
        
            attribute vec2 aPosition;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            uniform vec2 texelSize;
        
            void main () {
                vUv = aPosition * 0.5 + 0.5;
                float offset = 1.33333333;
                vL = vUv - texelSize * offset;
                vR = vUv + texelSize * offset;
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `);

            const blurShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;
        
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            uniform sampler2D uTexture;
        
            void main () {
                vec4 sum = texture2D(uTexture, vUv) * 0.29411764;
                sum += texture2D(uTexture, vL) * 0.35294117;
                sum += texture2D(uTexture, vR) * 0.35294117;
                gl_FragColor = sum;
            }
        `);

            const copyShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;
        
            varying highp vec2 vUv;
            uniform sampler2D uTexture;
        
            void main () {
                gl_FragColor = texture2D(uTexture, vUv);
            }
        `);

            const clearShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;
        
            varying highp vec2 vUv;
            uniform sampler2D uTexture;
            uniform float value;
        
            void main () {
                gl_FragColor = value * texture2D(uTexture, vUv);
            }
        `);

            const colorShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
        
            uniform vec4 color;
        
            void main () {
                gl_FragColor = color;
            }
        `);


            const displayShaderSource = `
            precision highp float;
            precision highp sampler2D;
        
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uTexture;
            uniform sampler2D uDithering;
            uniform vec2 ditherScale;
            uniform vec2 texelSize;
        
            vec3 linearToGamma (vec3 color) {
                color = max(color, vec3(0));
                return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));
            }
        
            void main () {
                vec3 c = texture2D(uTexture, vUv).rgb;
        
            #ifdef SHADING
                vec3 lc = texture2D(uTexture, vL).rgb;
                vec3 rc = texture2D(uTexture, vR).rgb;
                vec3 tc = texture2D(uTexture, vT).rgb;
                vec3 bc = texture2D(uTexture, vB).rgb;
        
                float dx = length(rc) - length(lc);
                float dy = length(tc) - length(bc);
        
                vec3 n = normalize(vec3(dx, dy, length(texelSize)));
                vec3 l = vec3(0.0, 0.0, 1.0);
        
                float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
                c *= diffuse;
            #endif
        
                float a = max(c.r, max(c.g, c.b));
                gl_FragColor = vec4(c, a);
            }
        `;

            const splatShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            precision highp sampler2D;
        
            varying vec2 vUv;
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec3 color;
            uniform vec2 point;
            uniform float radius;
        
            void main () {
                vec2 p = vUv - point.xy;
                p.x *= aspectRatio;
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).xyz;
                gl_FragColor = vec4(base + splat, 1.0);
            }
        `);

            const advectionShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            precision highp sampler2D;
        
            varying vec2 vUv;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform vec2 dyeTexelSize;
            uniform float dt;
            uniform float dissipation;
        
            vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
                vec2 st = uv / tsize - 0.5;
        
                vec2 iuv = floor(st);
                vec2 fuv = fract(st);
        
                vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
                vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
                vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
                vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);
        
                return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
            }
        
            void main () {
            #ifdef MANUAL_FILTERING
                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
                vec4 result = bilerp(uSource, coord, dyeTexelSize);
            #else
                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
                vec4 result = texture2D(uSource, coord);
            #endif
                float decay = 1.0 + dissipation * dt;
                gl_FragColor = result / decay;
            }`,
                ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']
            );

            const divergenceShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;
        
            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uVelocity;
        
            void main () {
                float L = texture2D(uVelocity, vL).x;
                float R = texture2D(uVelocity, vR).x;
                float T = texture2D(uVelocity, vT).y;
                float B = texture2D(uVelocity, vB).y;
        
                vec2 C = texture2D(uVelocity, vUv).xy;
                if (vL.x < 0.0) { L = -C.x; }
                if (vR.x > 1.0) { R = -C.x; }
                if (vT.y > 1.0) { T = -C.y; }
                if (vB.y < 0.0) { B = -C.y; }
        
                float div = 0.5 * (R - L + T - B);
                gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `);

            const curlShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;
        
            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uVelocity;
        
            void main () {
                float L = texture2D(uVelocity, vL).y;
                float R = texture2D(uVelocity, vR).y;
                float T = texture2D(uVelocity, vT).x;
                float B = texture2D(uVelocity, vB).x;
                float vorticity = R - L - T + B;
                gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
            }
        `);

            const vorticityShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            precision highp sampler2D;
        
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uVelocity;
            uniform sampler2D uCurl;
            uniform float curl;
            uniform float dt;
        
            void main () {
                float L = texture2D(uCurl, vL).x;
                float R = texture2D(uCurl, vR).x;
                float T = texture2D(uCurl, vT).x;
                float B = texture2D(uCurl, vB).x;
                float C = texture2D(uCurl, vUv).x;
        
                vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
                force /= length(force) + 0.0001;
                force *= curl * C;
                force.y *= -1.0;
        
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity += force * dt;
                velocity = min(max(velocity, -1000.0), 1000.0);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `);

            const pressureShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;
        
            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uDivergence;
        
            void main () {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                float C = texture2D(uPressure, vUv).x;
                float divergence = texture2D(uDivergence, vUv).x;
                float pressure = (L + R + B + T - divergence) * 0.25;
                gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
            }
        `);

            const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;
        
            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uVelocity;
        
            void main () {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity.xy -= vec2(R - L, T - B);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `);

            const blit = (() => {
                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(0);

                return (target, clear = false) => {
                    if (target == null) {
                        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    }
                    else {
                        gl.viewport(0, 0, target.width, target.height);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
                    }
                    if (clear) {
                        gl.clearColor(0.0, 0.0, 0.0, 1.0);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                    }
                    // CHECK_FRAMEBUFFER_STATUS();
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                }
            })();

            function CHECK_FRAMEBUFFER_STATUS() {
                let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status != gl.FRAMEBUFFER_COMPLETE)
                    console.trace("Framebuffer error: " + status);
            }

            let dye;
            let velocity;
            let divergence;
            let curl;
            let pressure;
            let ditheringTexture = createTextureAsync('../app/themes/flipp/dist/images/LDR_LLL1_0.png');

            const blurProgram = new Program(blurVertexShader, blurShader);
            const copyProgram = new Program(baseVertexShader, copyShader);
            const clearProgram = new Program(baseVertexShader, clearShader);
            const colorProgram = new Program(baseVertexShader, colorShader);
            const splatProgram = new Program(baseVertexShader, splatShader);
            const advectionProgram = new Program(baseVertexShader, advectionShader);
            const divergenceProgram = new Program(baseVertexShader, divergenceShader);
            const curlProgram = new Program(baseVertexShader, curlShader);
            const vorticityProgram = new Program(baseVertexShader, vorticityShader);
            const pressureProgram = new Program(baseVertexShader, pressureShader);
            const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);

            const displayMaterial = new Material(baseVertexShader, displayShaderSource);

            function initFramebuffers() {
                let simRes = getResolution(config.SIM_RESOLUTION);
                let dyeRes = getResolution(config.DYE_RESOLUTION);

                const texType = ext.halfFloatTexType;
                const rgba = ext.formatRGBA;
                const rg = ext.formatRG;
                const r = ext.formatR;
                const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;

                gl.disable(gl.BLEND);

                if (dye == null)
                    dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);
                else
                    dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);

                if (velocity == null)
                    velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);
                else
                    velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);

                divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
                curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
                pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);

            }

            function createFBO(w, h, internalFormat, format, type, param) {
                gl.activeTexture(gl.TEXTURE0);
                let texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);

                let fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                gl.viewport(0, 0, w, h);
                gl.clear(gl.COLOR_BUFFER_BIT);

                let texelSizeX = 1.0 / w;
                let texelSizeY = 1.0 / h;

                return {
                    texture,
                    fbo,
                    width: w,
                    height: h,
                    texelSizeX,
                    texelSizeY,
                    attach(id) {
                        gl.activeTexture(gl.TEXTURE0 + id);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        return id;
                    }
                };
            }

            function createDoubleFBO(w, h, internalFormat, format, type, param) {
                let fbo1 = createFBO(w, h, internalFormat, format, type, param);
                let fbo2 = createFBO(w, h, internalFormat, format, type, param);

                return {
                    width: w,
                    height: h,
                    texelSizeX: fbo1.texelSizeX,
                    texelSizeY: fbo1.texelSizeY,
                    get read() {
                        return fbo1;
                    },
                    set read(value) {
                        fbo1 = value;
                    },
                    get write() {
                        return fbo2;
                    },
                    set write(value) {
                        fbo2 = value;
                    },
                    swap() {
                        let temp = fbo1;
                        fbo1 = fbo2;
                        fbo2 = temp;
                    }
                }
            }

            function resizeFBO(target, w, h, internalFormat, format, type, param) {
                let newFBO = createFBO(w, h, internalFormat, format, type, param);
                copyProgram.bind();
                gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));
                blit(newFBO);
                return newFBO;
            }

            function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {
                if (target.width == w && target.height == h)
                    return target;
                target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);
                target.write = createFBO(w, h, internalFormat, format, type, param);
                target.width = w;
                target.height = h;
                target.texelSizeX = 1.0 / w;
                target.texelSizeY = 1.0 / h;
                return target;
            }

            function createTextureAsync(url) {
                let texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255]));

                let obj = {
                    texture,
                    width: 1,
                    height: 1,
                    attach(id) {
                        gl.activeTexture(gl.TEXTURE0 + id);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        return id;
                    }
                };

                let image = new Image();
                image.onload = () => {
                    obj.width = image.width;
                    obj.height = image.height;
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
                };
                image.src = url;

                return obj;
            }

            function updateKeywords() {
                let displayKeywords = [];
                if (config.SHADING) displayKeywords.push("SHADING");
                displayMaterial.setKeywords(displayKeywords);
            }

            updateKeywords();
            initFramebuffers();

            let lastUpdateTime = Date.now();
            let colorUpdateTimer = 0.0;

            function update() {
                const dt = calcDeltaTime();
                // console.log(dt)
                if (resizeCanvas())
                    initFramebuffers();
                updateColors(dt);
                applyInputs();
                step(dt);
                render(null);
                requestAnimationFrame(update);
            }

            function calcDeltaTime() {
                let now = Date.now();
                let dt = (now - lastUpdateTime) / 1000;
                dt = Math.min(dt, 0.016666);
                lastUpdateTime = now;
                return dt;
            }

            function resizeCanvas() {
                let width = scaleByPixelRatio(canvas.clientWidth);
                let height = scaleByPixelRatio(canvas.clientHeight);
                if (canvas.width != width || canvas.height != height) {
                    canvas.width = width;
                    canvas.height = height;
                    return true;
                }
                return false;
            }

            function updateColors(dt) {

                colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;
                if (colorUpdateTimer >= 1) {
                    colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);
                    pointers.forEach(p => {
                        p.color = generateColor();
                    });
                }
            }

            function applyInputs() {
                pointers.forEach(p => {
                    if (p.moved) {
                        p.moved = false;
                        splatPointer(p);
                    }
                });
            }

            function step(dt) {
                gl.disable(gl.BLEND);

                curlProgram.bind();
                gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
                blit(curl);

                vorticityProgram.bind();
                gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
                gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
                gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
                gl.uniform1f(vorticityProgram.uniforms.dt, dt);
                blit(velocity.write);
                velocity.swap();

                divergenceProgram.bind();
                gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
                blit(divergence);

                clearProgram.bind();
                gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
                gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);
                blit(pressure.write);
                pressure.swap();

                pressureProgram.bind();
                gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
                for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                    gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));
                    blit(pressure.write);
                    pressure.swap();
                }

                gradienSubtractProgram.bind();
                gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));
                gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));
                blit(velocity.write);
                velocity.swap();

                advectionProgram.bind();
                gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                if (!ext.supportLinearFiltering)
                    gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);
                let velocityId = velocity.read.attach(0);
                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);
                gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);
                gl.uniform1f(advectionProgram.uniforms.dt, dt);
                gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
                blit(velocity.write);
                velocity.swap();

                if (!ext.supportLinearFiltering)
                    gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);
                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
                gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
                gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
                blit(dye.write);
                dye.swap();
            }

            function render(target) {
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.enable(gl.BLEND);
                drawDisplay(target);
            }

            function drawDisplay(target) {
                let width = target == null ? gl.drawingBufferWidth : target.width;
                let height = target == null ? gl.drawingBufferHeight : target.height;

                displayMaterial.bind();
                if (config.SHADING)
                    gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);
                gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));
                blit(target);
            }

            function splatPointer(pointer) {
                let dx = pointer.deltaX * config.SPLAT_FORCE;
                let dy = pointer.deltaY * config.SPLAT_FORCE;
                splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);
            }

            function clickSplat(pointer) {
                const color = generateColor();
                color.r *= 10.0;
                color.g *= 10.0;
                color.b *= 10.0;
                let dx = 10 * (Math.random() - 0.5);
                let dy = 30 * (Math.random() - 0.5);
                splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);
            }

            function splat(x, y, dx, dy, color) {
                splatProgram.bind();
                gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
                gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
                gl.uniform2f(splatProgram.uniforms.point, x, y);
                gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);
                gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));
                blit(velocity.write);
                velocity.swap();

                gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
                gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
                blit(dye.write);
                dye.swap();
            }

            function correctRadius(radius) {
                let aspectRatio = canvas.width / canvas.height;
                if (aspectRatio > 1)
                    radius *= aspectRatio;
                return radius;
            }

            window.addEventListener('mousedown', e => {
                let pointer = pointers[0];
                let posX = scaleByPixelRatio(e.clientX);
                let posY = scaleByPixelRatio(e.clientY);
                updatePointerDownData(pointer, -1, posX, posY);
                clickSplat(pointer);
            });

            $('body').one('mousemove', e => {
                let pointer = pointers[0];
                let posX = scaleByPixelRatio(e.clientX);
                let posY = scaleByPixelRatio(e.clientY);
                let color = generateColor();
                update();
                updatePointerMoveData(pointer, posX, posY, color);
            });

            window.addEventListener('mousemove', e => {
                let pointer = pointers[0];
                let posX = scaleByPixelRatio(e.clientX);
                let posY = scaleByPixelRatio(e.clientY);
                let color = pointer.color;
                updatePointerMoveData(pointer, posX, posY, color);
            });

            $('body').one('touchstart', e => {
                const touches = e.targetTouches;
                let touch = touches[0]
                let pointer = pointers[0];
                for (let i = 0; i < touches.length; i++) {
                    let posX = scaleByPixelRatio(touches[i].clientX);
                    let posY = scaleByPixelRatio(touches[i].clientY);
                    update();
                    updatePointerDownData(pointer, touches[i].identifier, posX, posY);
                }
            });

            window.addEventListener('touchstart', e => {
                const touches = e.targetTouches;
                let pointer = pointers[0];
                for (let i = 0; i < touches.length; i++) {
                    let posX = scaleByPixelRatio(touches[i].clientX);
                    let posY = scaleByPixelRatio(touches[i].clientY);
                    updatePointerDownData(pointer, touches[i].identifier, posX, posY);
                }
            });

            window.addEventListener('touchmove', e => {
                const touches = e.targetTouches;
                let pointer = pointers[0];
                for (let i = 0; i < touches.length; i++) {
                    let posX = scaleByPixelRatio(touches[i].clientX);
                    let posY = scaleByPixelRatio(touches[i].clientY);
                    updatePointerMoveData(pointer, posX, posY, pointer.color);
                }
            }, false);

            window.addEventListener('touchend', e => {
                const touches = e.changedTouches;
                let pointer = pointers[0];

                for (let i = 0; i < touches.length; i++) {
                    updatePointerUpData(pointer);
                }
            });

            function updatePointerDownData(pointer, id, posX, posY) {
                pointer.id = id;
                pointer.down = true;
                pointer.moved = false;
                pointer.texcoordX = posX / canvas.width;
                pointer.texcoordY = 1.0 - posY / canvas.height;
                pointer.prevTexcoordX = pointer.texcoordX;
                pointer.prevTexcoordY = pointer.texcoordY;
                pointer.deltaX = 0;
                pointer.deltaY = 0;
                pointer.color = generateColor();
            }

            function updatePointerMoveData(pointer, posX, posY, color) {
                // pointer.down = false;
                pointer.prevTexcoordX = pointer.texcoordX;
                pointer.prevTexcoordY = pointer.texcoordY;
                pointer.texcoordX = posX / canvas.width;
                pointer.texcoordY = 1.0 - posY / canvas.height;
                pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);
                pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);
                pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;
                pointer.color = color;
            }

            function updatePointerUpData(pointer) {
                pointer.down = false;
            }

            function correctDeltaX(delta) {
                let aspectRatio = canvas.width / canvas.height;
                if (aspectRatio < 1) delta *= aspectRatio;
                return delta;
            }

            function correctDeltaY(delta) {
                let aspectRatio = canvas.width / canvas.height;
                if (aspectRatio > 1) delta /= aspectRatio;
                return delta;
            }

            function generateColor() {
                const baseR = 0xff / 255;
                const baseG = 0xff / 255;
                const baseB = 0xff / 255;
                const shade = Math.random();
                
                let r = baseR * shade;
                let g = baseG * shade;
                let b = baseB * shade;
                
                r *= 0.15;
                g *= 0.15;
                b *= 0.15;

                return { r, g, b };
            }

            // 색상 변환시

            // function generateColor () {
            //     let c = HSVtoRGB(Math.random(), 1.0, 1.0);
            //     c.r *= 0.15;
            //     c.g *= 0.15;
            //     c.b *= 0.15;
            //     return c;
            // }

            // function HSVtoRGB(h, s, v) {
            //     let r, g, b, i, f, p, q, t;
            //     i = Math.floor(h * 6);
            //     f = h * 6 - i;
            //     p = v * (1 - s);
            //     q = v * (1 - f * s);
            //     t = v * (1 - (1 - f) * s);

            //     switch (i % 6) {
            //         case 0: r = v, g = t, b = p; break;
            //         case 1: r = q, g = v, b = p; break;
            //         case 2: r = p, g = v, b = t; break;
            //         case 3: r = p, g = q, b = v; break;
            //         case 4: r = t, g = p, b = v; break;
            //         case 5: r = v, g = p, b = q; break;
            //     }

            //     return {
            //         r,
            //         g,
            //         b
            //     };
            // }

            function wrap(value, min, max) {
                let range = max - min;
                if (range == 0) return min;
                return (value - min) % range + min;
            }

            function getResolution(resolution) {
                let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
                if (aspectRatio < 1)
                    aspectRatio = 1.0 / aspectRatio;

                let min = Math.round(resolution);
                let max = Math.round(resolution * aspectRatio);

                if (gl.drawingBufferWidth > gl.drawingBufferHeight)
                    return { width: max, height: min };
                else
                    return { width: min, height: max };
            }

            function scaleByPixelRatio(input) {
                let pixelRatio = window.devicePixelRatio || 1;
                return Math.floor(input * pixelRatio);
            }

            function hashCode(s) {
                if (s.length == 0) return 0;
                let hash = 0;
                for (let i = 0; i < s.length; i++) {
                    hash = (hash << 5) - hash + s.charCodeAt(i);
                    hash |= 0;
                }
                return hash;
            };
        };
    </script>
</body>
</html>
